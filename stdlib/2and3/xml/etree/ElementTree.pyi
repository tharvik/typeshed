# Stubs for xml.etree.ElementTree

from typing import (
    Callable, IO, Iterator, Iterable, Mapping, MutableMapping, Optional, Sequence, Sized, Tuple, Union,
    TypeVar, overload
)
import sys
from xml.parsers.expat import XMLParserType

_T = TypeVar('_T')
_IOT = TypeVar('_IOT', bytes, str)

_Text = Union[bytes, str]
_NS = Optional[Mapping[str, str]]

def Comment(text: Optional[_Text] = ...) -> Element: ...
def dump(elem: Union[Element, ElementTree]) -> None: ...
def fromstring(text: str) -> Element: ...
def fromstringlist(sequence: Sequence[str],
                   parser: Optional[XMLParserType] = ...) -> Element: ...
def iselement(element: Element) -> bool: ...
def iterparse(source: Union[str, IO[str]], events: Optional[str] = ...,
              parser: Optional[XMLParser] = ...) -> Iterator[Tuple[str, Element]]: ...
def parse(source: Union[str, IO[str]],
          parser: Optional[XMLParserType] = ...) -> ElementTree: ...

def ProcessingInstruction(target: str,
                          text: Optional[str] = ...) -> Element: ...
def register_namespace(prefix: str, uri: str) -> None: ...
def SubElement(parent: Element, tag: _Text, attrib: Mapping[_Text, _Text] = ...,
               **extra: _Text) -> Element: ...
if sys.version_info >= (3, 4):
    # TODO find way to specifiy that by default, it returns bytes
    def tostring(element: Element, encoding: Optional[str] = ...,
                 method: Optional[str] = ...,
                 *, short_empty_elements: bool = ...) -> Union[str, bytes]: ...
    def tostringlist(element: Element, encoding: Optional[str] = ...,
                     method: Optional[str] = ..., *,
                     short_empty_elements: bool = ...) -> Union[List[bytes], List[str]]: ...
else:
    def tostring(element: Element, encoding: Optional[str] = ...,
                 method: Optional[str] = ...) -> Union[str, bytes]: ...
    def tostringlist(element: Element, encoding: Optional[str] = ...,
                     method: Optional[str] = ...) -> Union[List[bytes], List[str]]: ...
def XML(text: str, parser: Optional[XMLParserType] = ...) -> Element: ...
def XMLID(text: str,
          parser: Optional[XMLParserType] = ...) -> Tuple[Element, Mapping[str, Element]]: ...


class Element(Iterable[Element], Sized):
    tag = ...  # type: str
    text = ...  # type: Optional[str]
    tail = ...  # type: Optional[str]
    attrib = ...  # type: MutableMapping[str, str]
    def __init__(self, tag: str, attrib: Mapping[str, str] = ...,
                 **extra: str) -> None: ...
    def clear(self) -> None: ...
    @overload
    def get(self, key: str) -> Optional[str]: ...
    @overload
    def get(self, key: str, default: _T) -> Union[str, _T]: ...
    def items(self) -> Sequence[Tuple[str, str]]: ...
    def keys(self) -> List[str]: ...
    def set(self, key: str, value: str) -> None: ...
    def append(self, subelement: Element) -> None: ...
    def extend(self, elements: Sequence[Element]) -> None: ...
    def find(self, match: str, namespaces: _NS = ...) -> Optional[Element]: ...
    def findall(self, path: str, namespaces: _NS = ...) -> List[Element]: ...
    # TODO can restrict if default is not defined
    def findtext(self, path: str, default: Optional[_T] = ...,
                 namespaces: _NS = ...) -> Union[str, _T]: ...
    def getchildren(self) -> List[Element]: ...
    def getiterator(self, tag: Optional[str] = ...) -> Iterator[Element]: ...
    def insert(self, index: int, subelement: Element) -> None: ...
    def iter(self, tag: Optional[str] = ...) -> Iterator[Element]: ...
    def iterfind(self, path: str,
                 namespaces: _NS = ...) -> Iterator[Element]: ...
    def itertext(self) -> Iterator[str]: ...
    def makeelement(self, tag: str, attrib: Mapping[str, str]) -> Element: ...
    def remove(self, subelement: Element) -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def __getitem__(self, index: int) -> Element: ...
    def __setitem__(self, index: int, element: Element) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Element]: ...


class ElementTree:
    def __init__(self, element: Optional[Element] = ...,
                 file: Union[str, IO[str], None] = ...) -> None: ...
    def _setroot(self, element: Element) -> None: ...
    def find(self, path: str, namespaces: _NS = ...) -> Optional[Element]: ...
    def findall(self, path: str, namespaces: _NS = ...) -> List[Element]: ...
    def findtext(self, path: str, default: Optional[_T] = ...,
                 namespaces: _NS = ...) -> Union[str, _T]: ...
    def getiterator(self, tag: Optional[str] = ...) -> Iterator[Element]: ...
    def getroot(self) -> Element: ...
    def iter(self, tag: Optional[str] = ...) -> Iterator[Element]: ...
    def iterfind(self, path: str, namespaces: _NS = ...) -> Iterator[Element]: ...
    def parse(self, source: Union[str, IO[str]],
              parser: Optional[XMLParserType] = ...) -> None: ...
    if sys.version_info >= (3, 4):
        def write(self, file: Union[str, IO[_IOT]],
                  encoding: Optional[str] = ...,
                  xml_declaration: Optional[bool] = ...,
                  default_namespace: Optional[str] = ...,
                  method: Optional[str] = ...,
                  *, short_empty_elements: bool = ...) -> None: ...
    else:
        def write(self, file: Union[str, IO[_IOT]],
                  encoding: Optional[str] = ...,
                  xml_declaration: Optional[bool] = ...,
                  default_namespace: Optional[str] = ...,
                  method: Optional[str] = ...) -> None: ...


class QName:
    def __init__(self, text_or_uri: str, tag: Optional[str] = ...) -> None: ...

class TreeBuilder:
    def __init__(self, element_factory: Optional[Callable[[str, Mapping[str, str]], Element]] = ...) -> None: ...
    def close(self) -> None: ...
    def data(self, data: _Text) -> None: ...
    def end(self, tag: str) -> Element: ...
    def start(self, tag: str, attrs: Mapping[str, str]) -> Element: ...


#VERSION = ...  # type: Any

#class ParseError(SyntaxError): ...


#PI = ...  # type: Any


#class _ListDataStream(io.BufferedIOBase):
#    lst = ...  # type: Any
#    def __init__(self, lst): ...
#    def writable(self): ...
#    def seekable(self): ...
#    def write(self, b): ...
#    def tell(self): ...


#class XMLPullParser:
#    def __init__(self, events=None, *, _parser=None): ...
#    def feed(self, data): ...
#    def close(self): ...
#    def read_events(self): ...

#class _IterParseIterator:
#    root = ...  # type: Any
#    def __init__(self, source, events, parser, close_source=False): ...
#    def __next__(self): ...
#    def __iter__(self): ...



class XMLParser: ...
#    parser = ...  # type: Any
#    target = ...  # type: Any
#    entity = ...  # type: Any
#    version = ...  # type: Any
#    def __init__(self, html=0, target=None, encoding=None): ...
#    def doctype(self, name, pubid, system): ...
#    def feed(self, data): ...
#    def close(self): ...
